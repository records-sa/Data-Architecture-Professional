# 연습 문제

1. 다음 데이터베이스 관리 시스템의 추상화에 대한 설명으로 틀린 것은?
    1. ~~데이터베이스 관리 시스템은 데이터의 정의나 설명, 파일의 구조 등과 같은 데이터를 저장하고 있지만, 제약조건에 대한 정보는 별도로 관리하지 않음~~
        
        → 사용자 정의 제약조건 또는 Not Null과 같은 시스템적인 제약조건을 시스템 카탈로그 또는 데이터 사전에 관리하고 있음
        
    2. 데이터 파일의 구조가 프로그램으로부터 분리되어 시스템 카탈로그 또는 데이터 사전으로 관리되어짐
    3. 데이터베이스 관리 시스템은 사용자에게 데이터에 대한 개념적인 접근만을 제공하므로 물리적인 저장 구조를 알지 못해도 쉽게 사용할 수 있음
    4. 데이터베이스 관리 시스템에서 데이터의 독립성과 추상화는 매우 중요함
    
2. 데이터베이스 관리 시스템의 추상화 단계에 대한 설명으로 옳은 것은?
    1. *개념적 단계 - 추상화의 최상위 단계로 최종 사용자들이 관심을 갖는 데이터베이스의 부분만을 정의*
    2. 논리적 단계 - 데이터가 실제 어떻게 저장되어 있는지 원시 수준의 데이터 구조를 정의
        
        → 데이터베이스 전체 구조를 추상화하는 단계로 데이터베이스에 저장된 데이터와 데이터 간의 관련, 권한, 무결성과 같은 부가적인 정보를 저장
        
    3. 물리적 단계 - 데이터베이스의 전체 구조를  추상화하는 단계
        
        → 실제 데이터가 어떻게 저장되어 있는지 원시 수준의 데이터 구조를 정의
        
    4. 개념-물리 사상 - 개념적 스키마와 물리적 스키마 간의 대응 관계를 정의
        
        → 개념적-논리적, 논리적-물리적 단계가 존재
        

3. 다음 중 데이터베이스 관리 시스템의 구성요소에 포함되지 않는 것은?
    1. 데이터베이스 파일
    2. 데이터 저장 관리자
    3. 질의 처리기
    4. ~~응용프로그램~~
    
    → 데이터 베이스 관리 시스템의 구성요소: 데이터베이스 파일, 데이터 저장 관리자, 질의 처리기, 트랜잭션 관리자 등
    

4. 아래에서 설명하는 내용으로 옳은 것은?
    
    
    | 아래 |
    | :---: |
    | 데이터 파일로부터 읽어들인 데이터 블록의 사본을 가지고 있으며, 데이터베이스에 접속되어 있는 모든 사용자 프로세스에 의해 공유된다. |
    1. 데이터베이스 파일
    2. *데이터베이스 버퍼*
    3. 공유 풀
    4. 로그 버퍼
    
5. 다음 데이터 명령어에 대한 설명으로 옳은 것은?
    1. *테이블, 인덱스 등의 스키마 객체를 생성, 변경하는 등의 역할을 하는 명령어를 데이터 정의어(DDL) 이라 함*
        
        → 명령어로 CREATE, ALTER, DROP, RENAME, TRUNCATE 등이 있음
        
    2. 데이터 조작어(DML)로는 SELECT, INSERT, UPDATE, DELETE, ~~TRUNCATE~~ 등이 있음
    3. 데이터 조작어에서 SELECT를 제외한 다른 명령어는 ROLLBACK 명령어를 이용하여 변경된 데이터를 영구적으로 반영시켜야 함
        
        → ROLLBACK은 변경된 데이터를 원래의 데이터로 되돌리는 명령어로, 변경된 데이터를 영구적으로 반영하는 명령어는 COMMIT
        
    4. GRANT, REVOKE는 트랜잭션 제어어(TCL)에 포함됨
        
        → TCL: 1개 이상의 SQL문을 논리적인 하나의 처리 단위로 적용하기 위해 사용하는 명령어로 COMMIT, ROLLBACK 등이 있음
        

6. 트랜잭션의 특성으로 틀린 것은?
    1. 하나의 트랜잭션은 하나의 원자적 수행으로, 모두 성공하거나 모두 실패해야 함
    2. 트랜잭션을 실행하면 데이터베이스는 하나의 일관된 상태에서 또 다른 일관된 상태로 변경됨
    3. 특정 트랜잭션이 변경하는 데이터는 그 트랜잭션이 완료될 때까지 다른 트랜잭션들은 볼 수 없음
    4. ~~트랜잭션이 완료되면 데이터는 데이터베이스에 영구보관되지만, 어떠한 고장에 의해 유실될 수 있음~~
        
        → 어떠한 고장에도 유실되지 않아야 함
        

7. 다음 성능 개선 목표 중 처리 시간(Throughput Time) 개선에 대한 설명으로 가장 옳은 것은?
    1. 해당 작업을 수행하기 위해 소요되는 시간으로 OLTP 시스템의 성능 척도임
        
        → 처리 시간 개선은 주로 DW/DM과 같은 대용량 배치 처리 시스템의 성능 척도이며, OLTP 시스템의 성능 척도는 응답 시간
        
    2. *인덱스 스캔보다는 Full Table Scan을 실시하며, 병렬 처리를 실시함*
    3. Hash 조인의 수행보다는 Nested-Loop 또는 Sort-Merge 조인으로 처리
        
        → Nested-Loop  조인 보다는 대용량 처리를 위해 Hash 조인을 주로 사용
        
    4. 절차적 SQL을 이용한 처리가 효율적임
        
        → 절차적 SQL은 가급적 지양
        

8. 다음 중 옵티마이저에 대한 설명으로 가장 틀린 것은?
    1. 옵티마이저는 사용자가 제시한 SQL을 처리하기 위한 최적의 실행 계획을 찾음
    2. ~~옵티마이저는 최적의 실행 계획을 찾기 위해 모든 경우의 수를 확인함~~
        
        → 옵티마이저가 모든 경우의 수를 확인할 경우 실제 SQL 수행시간보다 계획을 찾는데 소요되는 시간이 훨씬 더 클 수 있음
        
        → 옵티마이저는 테이블, 인덱스 등의 통계 정보를 기반으로 최적의 실행 계획일 가능성이 높은 실행 계획을 찾는 알고리즘을 내장하고 있음
        
    3. 실행 계획을 찾는 과정에서 SQL을 처리하는데 소요되는 비용을 산출
    4. 현재 RBO 는 사용하지 않으며, CBO로 대체됨

9. 다음 조인 기법에 대한 설명으로 옳은 것은?
    1. Sort-Merge Join은 Join하려는 두 집합을 Join Column으로 정렬하여 Sorted-List를 만들고 병합하는 Join 기법으로, OLTP System에서 활용도가 높음
        
        → 대용량 배치 처리 System에서 활용도가 높음
        
    2. *Hash Join은 대용량의 데이터 Join 시에 Sort-Merge Join이나 Nested-Loop Join보다 효율적임*
    3. Nested-Loop Join은 Driving Table(Outer Table)과 Inner Table 양쪽 모두 인덱스가 없을 때 효율적인 Join 기법
        
        → Hash Join이 효율적
        
    4. Nested-Loop Join에서 두 Table 간의 Join 시 Driving Table(Outer Table)과 Inner Table의 결정은 일의 양과 관계가 없음
        
        → Driving Table 의 결정은 전체 수행하는 일의 양에 결정적인 역할을 함
        

10. 다음 서버 성능 개선에 대한 설명으로 가장 틀린 것은?
    1. 데이터베이스의 객체는 I/O 병목이 발생하지 않게 물리적인 배치를 실시함
    2. 메모리는 데이터베이스 버퍼, 공유 풀 등의 히트율에 의해서 평가하여 조정해야 함
    3. 객체 생성이나 변경은 Latch 경합이 발생할 수 있으므로 주의해야 함
    4. ~~데이터베이스의 질의 수행 시 병목 현상은 주로 네트워크에서 발생하므로 가능한 한 네트워크 Bandwidth를 크게 해야 함~~
        
        → 병목 현상은 주로 디스크 I/O에서 발생함